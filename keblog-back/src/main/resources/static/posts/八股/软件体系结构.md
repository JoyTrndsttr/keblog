# 重点

## 概述（5分，选填）

定义（三个组成）

优势（4个）

## 软件体系风格（10分，1简答，7分选填）

定义（是什么，定义了什么，反映了什么）

八种常见软件体系风格有哪些

C/S结构于B/S结构的区别和优缺点以及混合结构的好处

三层C/S结构优缺点

## UML（22分，1综合，1简答，9分选填）

包括：模型元素 通用机制

UML图：定义+场景，根据图背出组成元素，会画用例图，记得步骤

### 行为图

#### 用例图

定义：用例的方法描述系统功能需求

场景：功能建模

组成：用例图（执行者、用例） 用例描述文档（用例编号、用例名、执行者、前置条件、后置条件、基本路径、扩展路径...）

步骤：5个

重点：要会画图

#### 状态图

定义：特定状态+引起状态转移的条件

场景：有重要交互行为，存在复杂对象

组成：初始状态 状态 动作 **转移** 事件 守护条件 终止状态

#### 活动图

定义：表示系统各种活动的次序（用例的工作流程或类中某方法的操作行为）

场景：事件流逻辑复杂（UML中的流程图）

组成：泳道、起始活动、转移（带实心三角箭头实线）、活动（圆角矩形）、决策（菱形框）、守护条件、同步条、对象流（带箭头虚线）、对象（矩形）、终止活动

#### 顺序图

定义和场景：用于确认和丰富一个使用情境的逻辑，清晰显示时间次序

组成：对象、生命线、激活、消息、交互片段（alt,opt,par,loop,critical)

#### 通信图

定义：与顺序图同构，清晰显示对象间关系

应用场景：对象及其连接有利于理解交互

组成元素：执行者、对象、连接、消息、守护条件

#### 定时图

定义：采用带数字刻度的时间轴来精确描述消息的顺序

应用场景：需要对实时事件进行建模

#### 交互概览图

定义：活动图+顺序图

应用场景：可读性低，一般不用

### 结构图

#### 类图

关联关系：通常将一个类的对象作为另一个类的属性

关联关系包含：

- 双向关联：不带箭头的实线
- 单向关联：箭头的实线
- 自关联：带箭头的实线指向自己
- 多重性关联：带箭头实现标上数字
- 聚合关系Aggregation：带空心菱形的直线，局部可脱离整体
- 组合关系Composition：带实心菱形的直线，同生共死

依赖关系：方法参数、局部变量、调用静态方法等，用带箭头的虚线表示

泛化关系：带空心三角形的直线表示

接口与实现关系：带空心三角形的虚线表示

#### 包图

定义：把元素组织到一起到通用机制，描述包与包之间的关系

包之间三种关系：引入、泛化、嵌套

#### 组件图

（组件就是一个实际文件）

定义：显示组件以及它们之间的依赖关系以及组件的接口和调用关系

使用场景：多个组件组成的大系统，说明组件的逻辑关系

组成元素：组件、接口、部件（组件的局部实现）、端口（与外界交互点）、连接件（通信关系）

组件间关系：泛化、依赖

#### 部署图

定义:显示系统的软硬件及连接异构计算机的中间件

应用场景：比组件图进一步描述系统硬件的物理拓扑结构及此结构上运行的软件

组成元素：节点（物理设备）、连接（通信路径）、组件（可执行的物理代码模块）

#### 对象图

定义：类图某一时刻的一个实例

应用场景：需要一个类图实例

#### 组合结构图

定义：表示类的内部结构

应用场景：适用于含有内部类的类与外部接口之间的相互关系

组成元素：部件（内部成分），连接件（部件关系），端口（与外部环境的交互点）

### 软件质量属性（8分，1简答，5分选填）

#### 质量目标和商业目标

- 高质量软件符合商业目标和用户需求
- 商业目标决定质量目标

- 企业需衡量质量、效率和成本

#### 外部质量7种

#### 内部质量6种

#### 过程质量5个方面

### 面向对象设计原则（10分，1综合，1简答，3分选填）

7种设计原则定义+理解（翻译一遍+简单理解+高层理解）

#### 单一职责原则 Single Responsibility Principle

定义：一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中

理解：

- 一个类仅有一个引起它变化的原因，不同职责封装在不同类中
- 职责越多复用越难，一个职责变化可能影响其他职责
- 实现高内聚、低耦合

#### 开闭原则 Open-Closed Principle

定义：软件实体应当对扩展开放，对修改关闭

理解：

- 不修改源代码进行扩展
- 抽象化，相对稳定的抽象层+灵活的具体层
- 对可变性封装原则(Principle of Encapsulation of Variation, EVP)：找到系统的可变因素并将其封装起来

#### 里氏代换原则 Liskov Substitution Principle

定义：所有引用基类的地方必须能透明地用其子类的对象

理解：

- 基类对象替换成子类对象程序不产生错误或异常，反过来不成立
- 尽量使用基类类型来对对象进行定义，运行时再确定子类类型

#### 依赖倒转原则 Dependency Inversion Principle

定义：抽象不应依赖于细节，细节应该依赖于抽象

理解：

- 针对接口编程，而不是针对实现编程
- 传参或关联关系中，尽量引入高层次抽象层类（接口或抽象类）
- 程序中尽量使用抽象层进行编程，具体类写配置文件中，具体类对象通过依赖注入（Dependency Injection）的方式注入到其他对象（构造、设值、接口）

#### 接口隔离原则 Interface Segregation Principle

定义：客户端不应该依赖那些它不需要的接口

理解：

- 应当为客户提供尽可能小的单独的接口，而不是提供大的总接口
- 每个接口承担一种相对独立的角色

#### 合成复用原则 Composite Reuse Principle

定义：优先使用对象组合，而不是继承来达到复用的目的

理解：

- 复用时尽量使用组合/聚合关系，少用继承

- 新对象中通过关联关系来使用已有对象，通过委派调用已有对象的方法达到复用功能
- 继承复用实现简单、易于扩展，但破坏系统的封装性，从基类继承而来的实现是静态的，不够灵活，使用环境有限
- 组合/聚合复用耦合度相对较低，新对象可以动态地引用与成员对象类型相同的其他对象

#### 迪米特法则 Law of Demeter （最小知识原则 Least Knowledge Principle)

定义：每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位

理解：

- 一个软件实体应当尽可能少地与其他实体发生相互作用
- 减少对象之间交互，如果对象之间不必直接通信，就不应该有直接的相互作用
- 如果一个对象需要调用另一个对象的方法，可以通过“第三者”转发调用
- 可以降低系统的耦合度

## 常用设计模式（45分）

15种设计模式定义+理解

工厂模式单独考

组合模式+观察者模式

单例模式+观察者模式

策略模式+适配器模式

### 创建型模式

- 关注对象的创建过程
- 对象的创建和使用分离

##### 对象的创建和使用分离好处

- 降低耦合度，便于维护
- 解决代码重复、创建蔓延（指实例化类到处都是）
- 提高代码可读性

##### Java语言创建对象的几种方法

new关键字、反射机制、克隆方法、工厂类

##### Java反射机制

定义：程序运行时获取一直名称的类或已有对象

使用：

```java
Class c = Class.forname("java.lang.String");
Object obj = c.newInstance();
```

#### 简单工厂模式 Simple Factory Pattern

定义：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类

- 使用场景需要什么只要传个参数，无需知道具体细节
- 工厂类创建的对象比较少
- 不关心扩展

组成：工厂（含静态方法）、抽象产品、具体产品

关系：工厂关联（多个）具体产品，具体产品实现抽象产品

优点：

- 对象创建和使用分离
- 客户端只需知道参数而不是类名
- 引入配置文件能不修改客户端代码更换和增加具体产品类提高灵活性

缺点：

- 违反单一职责原则，违反开闭原则
- 增加类的个数
- 系统扩展困难，加新产品得修改工厂逻辑
- 静态工厂方法导致工厂无法形成基于继承的等级结构，难以扩展

#### 工厂方法模式 Factory Method Pattern

定义：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。

使用场景：

- 客户端不知道它所需要的对象的类
- 抽象工厂类通过子类来创建哪个对象

组成：抽象产品，具体产品，抽象工厂，具体工厂

关系：具体产品继承抽象产品，具体工厂继承抽象工厂，具体工厂依赖具体产品

优点：

- 向客户隐藏哪种具体产品类将被实例化
- 让工厂自主确定创建何种产品对象，创建细节封装在具体工厂内部
- 系统加入新产品时符合开闭原则

缺点：

- 类的个数成对增加
- 增加系统的抽象性和理解难度

#### 抽象工厂模式 Abstract Factory Pattern

定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类

使用场景：

- 系统不依赖于产品类创建过程
- 系统有多个产品族，一次使用某一种，同一种的产品一起使用
- 产品等级结构稳定

组成：抽象工厂（接口）、具体工厂、抽象产品（接口）、具体产品

关系：（多个）具体工厂实现抽象工厂，（多个）具体产品实现抽象产品，（每个）具体工厂依赖（多个）具体产品

优点：

- 隔离具体类生成
- 保证客户端只使用一个产品族中的对象
- 增加新的产品族很方便，符合开闭原则

缺点：

- 增加产品等级结构违背开闭原则

##### 产品族与产品等级结构

产品族：同一工厂生产

产品等级结构：产品继承结构（实现产品接口）

##### 开闭原则的倾斜性

- 增加产品族只需加具体产品和具体工厂，支持开闭原则
- 增加产品等级结构要修改抽象工厂类和具体工厂类，增加生产新产品的方法，违背开闭原则

#### 原型模式 Prototype Pattern

定义：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象

使用场景：

组成：抽象原型、具体原型、客户

关系：

- 具体原型继承抽象原型，客户关联或依赖抽象原型（一般图不这样画）
- 浅克隆：原型聚合引用成员变量，原型继承Object和Cloneable接口
- 深克隆：原型聚合引用成员变量，原型和引用成员变量继承Serializable接口

优点：

- 简化对象创建过程
- 扩展性较好
- 提供了简单的创建结构（指不需要工厂类）
- 可以深克隆保存对象的状态，辅助实现撤销操作

缺点：

- 需要为每一个类配备克隆方法，对已有类改造需要修改源代码，违背开闭原则（我猜应该是深克隆加入引用成员变量）
- 实现深克隆要编写较为复杂的代码（尤其多重嵌套引用）

##### 浅克隆和深克隆

浅克隆：只复制原型对象本身和值类型变量，引用类型成员变量不复制

深克隆：所有

##### 原型管理器

专门负责克隆对象的工厂，定义了一个集合用于存储原型对象

#### 单例模式 Singleton Pattern

定义：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例

适用环境：只要一个实例对象；只允许使用一个公共访问点。

组成：单例

关系：单例类聚合自己（引入自己作为静态私有成员变量，有get自己的静态公有方法）

分类：

- 饿汉式单例：成员变量立即实例化。无需考虑多线程访问，速度快，资源利用效率低，加载时间长

- 懒汉式单例：自己依赖自己，成员变量实例化为null，get里面创建自己。实现了延迟加载，必须处理多线程访问影响性能

  - 延迟加载基础版：判断instance为空就新建实例，多线程同时访问会创建多个单例对象

  - 延迟加载改进版之锁方法：声明get方法时加synchronized

  - 延迟加载改进版之锁代码段:

    ```java
    synchronized(LazySingleton.class){
      instance = new LazySingleton();
    }
    ```

  - 延迟加载改进版之双重检查锁定：判断+锁代码+判断，再创建单例实例

- 静态内部类实现loDH

优点：唯一实例；节约资源；可实现多例类

缺点：扩展困难（缺少抽象层），职责过重，状态丢失（自动垃圾回收机制）

### 结构型模式

关注如何从不同角度将现有类或对象组织在一起

类结构型模式：继承+实现

对象结构型模式：关联

#### 适配器模式

定义：将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作

使用场景：使用现有的类（适配者）但接口不符合需要，没源代码；可以重复使用的适配没太大关联的类

组成：目标抽象类，适配器类，适配者类

关系：

- 类适配器：用户依赖目标接口，适配器实现目标接口，适配器继承适配者
- 对象适配器：用户依赖目标抽象类，适配器继承目标抽象类，适配器关联适配者
- 缺省适配器模式：设计抽象类（缺省适配器）实现目标接口，提供默认实现，适配者继承缺省适配器
- 双向适配器：适配器同时实现和关联目标接口和适配者

优点：

- 将目标类和适配者类解耦
- 增加类的透明性和复用性
- 灵活性和扩展性好
- 类适配器可以置换适配者的方法
- 对象适配者可以适配多个适配者

缺点：

- 类适配器：一次只能适配一个适配者，适配者类不能为最终类，抽象类只能为接口
- 对象适配器：在适配器中置换适配者的某些方法比较麻烦

#### 桥接模式 Bridge Pattern

定义：将抽象部分与它的实现部分解耦，使得两者都能够独立变化

使用场景：避免静态继承增加灵活性；多个独立变化的维度；不希望继承出很多类

组成：抽象类、扩充抽象类（不是抽象类）、实现类接口、具体实现类

关系：（多个）扩充抽象类继承抽象类，抽象类聚合（桥）实现类接口，具体实现类实现实现类接口

优先：

- 分离抽象接口和实现部分
- 取代多层继承，减少子类个数
- 提高系统可扩展性，符合开闭原则

缺点：增加系统的理解与设计难度，难以识别系统中两个独立变化的维度

#### 组合模式 Composite Pattern

定义：组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。

使用场景：处理树形结构；处理整体与部分的层次结构且忽略差异；分离叶子和容器对象且要加类型（？）

组成：抽象构建、叶子构建、容器构建

关系：叶子构建和容器构建继承抽象构建，容器构建聚合抽象构建

分类：

- 透明组合模式：抽象构建声明所有方法；一视同仁，不够安全
- 安全组合模式：抽象构建只有operation，没有管理成员变量方法；不够透明，客户端不能完全针对抽象编程，要区别叶子和容器

优先：

- 清晰分层且忽略层次差异
- 简化代码，不用关心叶子还是容器
- 增加新的容器和叶子都很方便，符合开闭原则
- 为树形结构的面相对象实现提供一种灵活的解决方案

缺点：增加新构建时很难对容器中的构建类型进行限制

#### 外观模式 Facade Pattern

定义：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得子系统更加容易使用

使用场景：为访问一些列子系统提供简单入口；客户端与多个子系统有很大依赖性；层次化通过外观类建立联系降低层之间耦合度

组成：外观角色 子系统角色 （抽象外观类）

关系：外观角色关联多个子系统角色 （外观角色继承抽象外观类 每个抽象外观类可以有独特的子系统）

优点：对客户端屏蔽子系统组件；子系统与客户端松耦合；子系统内部变化不影响外观对象

缺点：限制客户端使用子系统类不好控制，限制太多减少可变性和灵活性；增加新子系统修改外观类源代码违背开闭原则

#### 代理模式 Proxy Pattern

定义：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问

使用场景：

- 访问远程主机：远程代理
- 消耗大量资源：虚拟代理
- 频繁访问：缓冲代理
- 访问权限：保护代理
- 对对象的访问提供额外操作：智能引用代理

组成：抽象主题角色 代理主题角色 真实主题角色

关系：代理主题角色和真实主题角色继承抽象主题角色，代理主题角色关联真实主题角色

分类：保护代理；缓冲代理；智能引用代理

- 远程代理：访问远程主机，隐藏网络细节
- 虚拟代理：虚拟代理占资源或加载时间长的对象，提高性能。如快捷方式
- Java动态代理：让系统在运行时根据实际需要来动态创建代理类，代理多个不同的真实主题类和方法

优点：协调调用者和被调用者，降低系统的耦合度；客户端针对抽象主题角色进行编程，增加和更换代码类无需修改源代码，符合开闭原则；各种代理各有各的优点

缺点：可能会变慢（保护代理）；额外的工作

### 行为型模式

关注系统中对象的交互，进一步明确对象的职责

#### 适配器模式

定义：

使用场景：

组成：

关系：

优点：

缺点：

#### 适配器模式

定义：

使用场景：

组成：

关系：

优点：

缺点：

#### 适配器模式

定义：

使用场景：

组成：

关系：

优点：

缺点：

#### 适配器模式

定义：

使用场景：

组成：

关系：

优点：

缺点：

#### 适配器模式

定义：

使用场景：

组成：

关系：

优点：

缺点：