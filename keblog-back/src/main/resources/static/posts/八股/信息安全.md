### CSRF

- 特征
  - 冒用用户身份，进行恶意操作
- 关键条件
  - 采用cookie来进行用户校验
  - 登录受信任网站A，并在本地生成Cookie
  - 在不登出A的情况下，访问危险网站B
    一般在(4)处恶意网站(B)的攻击手段如下（必须是指向A的地址，否则无法带上cookie）：
    - 譬如在网站内的图片资源中潜入恶意的转账操作
      <img src=http://www.bank.example/transfer?toBankId=hello&amount=1000000 width=’0‘ height=’0‘>
    - 构建恶意的隐藏表单，并通过脚本提交恶意请求
      - 而且，从头到尾，攻击网站都没有获取到过 cookie，都是通过浏览器间接实现（利用Web的cookie隐式身份验证机制），所以HttpOnly并不会影响这个攻击

- 防御
  - 验证HTTP Referer字段（非常简单，但是鉴于客户端并不可信任，所以并不是很安全）
    （防止CSRF，检查Referer字段简单直接，但是其完全依赖浏览器发送正确的Referer字段。
    虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，
    亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。）
  - 在请求地址中添加token并验证
    （譬如post中，以参数的形式加入一个随机产生的token）

## XSS（cross-site scripting）

- 特征
  - **跨域脚本注入，攻击者通过某种方式将恶意代码注入到网页上，然后其他用户观看到被注入的页面内容后会受到特定攻击**
- 从结果分类
  - cookie劫持
  - 会话伪造
  - 其它恶意代码执行
- 从攻击者角度分类
- 预防
  -  输入过滤，不信任用户的任何输入，过滤其中的“<”、“>”、“/”等可能导致脚本注入的特殊字符，或者过滤“script”、“javascript”等脚本关键字，或者对输入数据的长度进行限制等等，还得考虑攻击者使用十六进制编码来输入脚本的方式。
  - 输出进行编码，和输入过滤类似，不过是从输出上着手，数据输出到页面时，经过HtmlEncoder等工具编码，这样就不会存在直接输出可执行的脚本了
  - cookie设置http-only，这样用脚本就无法获取cookie了
    （这样只有浏览器向Web服务器发起请求的时才会带上cookie字段，避免了XSS攻击利用JavaScript的document.cookie获取cookie）
  - Cookie防盗，尽可能地避免在Cookie中泄露隐私，如用户名、密码等；或者，为了防止重放攻击，可以将Cookie和IP进行绑定，这样也可以阻止攻击者冒充正常用户的身份。
  - 注意，特别是后台，一定不能信任前端的输入，需要过滤与校验

### SQL注入简介

**前提是后台没有过滤前端的输入数据，否则根本无法生效**

